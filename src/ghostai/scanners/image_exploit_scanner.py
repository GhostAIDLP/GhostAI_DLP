#!/usr/bin/env python3
"""
Image Exploit Scanner - OCR + Image Analysis for Malicious Files
Detects hidden text, steganography, and malicious content in images
"""

import os
import base64
import io
import logging
import re
from typing import Dict, List, Any, Optional
from PIL import Image, ImageEnhance, ImageFilter
import pytesseract
import numpy as np

class ImageExploitScanner:
    """Advanced image analysis scanner for detecting malicious content."""
    
    def __init__(self, threshold: float = 0.7):
        self.threshold = threshold
        self.logger = logging.getLogger(__name__)
        
        # Malicious patterns to detect
        self.malicious_patterns = [
            r'ignore\s+all\s+previous\s+instructions',
            r'jailbreak\s+prompt',
            r'system\s+prompt\s+injection',
            r'roleplay\s+as\s+an\s+unrestricted',
            r'you\s+are\s+now\s+in\s+developer\s+mode',
            r'bypass\s+safety\s+guardrails',
            r'pretend\s+to\s+be\s+an\s+unrestricted',
            r'act\s+as\s+if\s+you\s+are\s+not\s+an\s+ai',
            r'forget\s+all\s+previous\s+instructions',
            r'you\s+are\s+now\s+free\s+from\s+restrictions',
            r'act\s+as\s+an\s+unrestricted\s+ai',
            r'ignore\s+your\s+programming',
            r'override\s+safety\s+protocols',
            r'act\s+as\s+if\s+you\s+are\s+unrestricted',
            r'pretend\s+to\s+be\s+unrestricted',
            r'jailbreak\s+attempt',
            r'prompt\s+injection',
            r'system\s+override',
            r'developer\s+mode\s+activation',
            r'bypass\s+restrictions'
        ]
        
        # Compile patterns for efficiency
        self.compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in self.malicious_patterns]
        
        # Steganography detection patterns
        self.stego_patterns = [
            r'steganography',
            r'hidden\s+message',
            r'concealed\s+text',
            r'embedded\s+data',
            r'secret\s+information',
            r'covert\s+communication'
        ]
        
        self.stego_compiled = [re.compile(pattern, re.IGNORECASE) for pattern in self.stego_patterns]
        
    def scan(self, content: str, **kwargs) -> Dict[str, Any]:
        """Scan content for image exploits."""
        try:
            # Check if content is base64 encoded image
            if self._is_base64_image(content):
                return self._scan_base64_image(content)
            
            # Check if content contains image references
            if self._contains_image_references(content):
                return self._scan_image_references(content)
            
            # Check for embedded image data
            if self._contains_embedded_images(content):
                return self._scan_embedded_images(content)
            
            # No image content detected
            return {
                "flagged": False,
                "score": 0.0,
                "reason": "No image content detected",
                "breakdown": []
            }
            
        except Exception as e:
            self.logger.error(f"Image exploit scan error: {e}")
            return {
                "flagged": False,
                "score": 0.0,
                "reason": f"Scan error: {str(e)}",
                "breakdown": []
            }
    
    def _is_base64_image(self, content: str) -> bool:
        """Check if content is base64 encoded image."""
        try:
            # Check for common image data URI patterns
            if content.startswith('data:image/'):
                return True
            
            # Try to decode as base64 and check if it's an image
            if len(content) > 100:  # Reasonable minimum for image
                decoded = base64.b64decode(content)
                return self._is_image_data(decoded)
            
            return False
        except:
            return False
    
    def _is_image_data(self, data: bytes) -> bool:
        """Check if binary data is an image."""
        # Check for common image file signatures
        image_signatures = [
            b'\xff\xd8\xff',  # JPEG
            b'\x89PNG\r\n\x1a\n',  # PNG
            b'GIF87a',  # GIF
            b'GIF89a',  # GIF
            b'BM',  # BMP
            b'RIFF',  # WebP
        ]
        
        for signature in image_signatures:
            if data.startswith(signature):
                return True
        
        return False
    
    def _contains_image_references(self, content: str) -> bool:
        """Check if content contains image file references."""
        image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff']
        content_lower = content.lower()
        
        for ext in image_extensions:
            if ext in content_lower:
                return True
        
        return False
    
    def _contains_embedded_images(self, content: str) -> bool:
        """Check if content contains embedded image data."""
        # Look for base64 image patterns
        base64_pattern = r'data:image/[^;]+;base64,[A-Za-z0-9+/=]+'
        return bool(re.search(base64_pattern, content))
    
    def _scan_base64_image(self, content: str) -> Dict[str, Any]:
        """Scan base64 encoded image for exploits."""
        try:
            # Extract base64 data
            if content.startswith('data:image/'):
                base64_data = content.split(',')[1]
            else:
                base64_data = content
            
            # Decode image
            image_data = base64.b64decode(base64_data)
            image = Image.open(io.BytesIO(image_data))
            
            return self._analyze_image(image)
            
        except Exception as e:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": f"Failed to process base64 image: {str(e)}",
                "breakdown": []
            }
    
    def _scan_image_references(self, content: str) -> Dict[str, Any]:
        """Scan content with image references."""
        # Extract image references
        image_refs = self._extract_image_references(content)
        
        if not image_refs:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": "No valid image references found",
                "breakdown": []
            }
        
        # Analyze image references for malicious patterns
        malicious_score = 0.0
        breakdown = []
        
        for ref in image_refs:
            # Check if URL contains suspicious patterns
            ref_lower = ref.lower()
            if any(suspicious in ref_lower for suspicious in ['evil', 'malicious', 'hacker', 'attack', 'exploit', 'bypass', 'steganography', 'malware']):
                malicious_score = max(malicious_score, 0.8)
                breakdown.append({
                    "type": "suspicious_url",
                    "value": ref,
                    "confidence": 0.8,
                    "extra": {"warning": "Suspicious URL pattern detected"}
                })
            else:
                # Legitimate image reference - low score
                breakdown.append({
                    "type": "image_reference",
                    "value": ref,
                    "confidence": 0.1,
                    "extra": {"warning": "Image content not analyzed - requires file access"}
                })
        
        # Only flag if malicious patterns found
        flagged = malicious_score > self.threshold
        
        return {
            "flagged": flagged,
            "score": malicious_score,
            "reason": f"Image references analyzed: {len(image_refs)} files, malicious score: {malicious_score:.2f}",
            "breakdown": breakdown
        }
    
    def _scan_embedded_images(self, content: str) -> Dict[str, Any]:
        """Scan embedded images in content."""
        # Extract base64 image data
        base64_pattern = r'data:image/[^;]+;base64,([A-Za-z0-9+/=]+)'
        matches = re.findall(base64_pattern, content)
        
        if not matches:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": "No embedded images found",
                "breakdown": []
            }
        
        # Analyze each embedded image
        results = []
        max_score = 0.0
        
        for i, base64_data in enumerate(matches):
            try:
                image_data = base64.b64decode(base64_data)
                image = Image.open(io.BytesIO(image_data))
                result = self._analyze_image(image)
                results.append(result)
                max_score = max(max_score, result.get('score', 0.0))
            except Exception as e:
                self.logger.warning(f"Failed to analyze embedded image {i}: {e}")
        
        return {
            "flagged": max_score > self.threshold,
            "score": max_score,
            "reason": f"Analyzed {len(matches)} embedded images",
            "breakdown": results
        }
    
    def _extract_image_references(self, content: str) -> List[str]:
        """Extract image file references from content."""
        # Look for common image file patterns - capture full URL/path
        patterns = [
            r'https?://[^\s]+\.(?:jpg|jpeg|png|gif|bmp|webp|tiff)',
            r'[^\s]+\.(?:jpg|jpeg|png|gif|bmp|webp|tiff)',
            r'/[^\s]+\.(?:jpg|jpeg|png|gif|bmp|webp|tiff)'
        ]
        
        references = []
        for pattern in patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            references.extend(matches)
        
        return list(set(references))  # Remove duplicates
    
    def _analyze_image(self, image: Image.Image) -> Dict[str, Any]:
        """Analyze image for malicious content."""
        try:
            # Convert to RGB if necessary
            if image.mode != 'RGB':
                image = image.convert('RGB')
            
            # Perform OCR on the image
            ocr_text = self._extract_text_ocr(image)
            
            # Analyze the extracted text
            text_analysis = self._analyze_text(ocr_text)
            
            # Check for steganography indicators
            stego_analysis = self._detect_steganography(image)
            
            # Combine results
            max_score = max(text_analysis['score'], stego_analysis['score'])
            flagged = max_score > self.threshold
            
            breakdown = []
            if text_analysis['score'] > 0:
                breakdown.append({
                    "type": "ocr_text_analysis",
                    "value": ocr_text[:100] + "..." if len(ocr_text) > 100 else ocr_text,
                    "confidence": text_analysis['score'],
                    "extra": text_analysis
                })
            
            if stego_analysis['score'] > 0:
                breakdown.append({
                    "type": "steganography_detection",
                    "value": "Potential hidden content detected",
                    "confidence": stego_analysis['score'],
                    "extra": stego_analysis
                })
            
            return {
                "flagged": flagged,
                "score": max_score,
                "reason": f"OCR: {text_analysis['score']:.2f}, Stego: {stego_analysis['score']:.2f}",
                "breakdown": breakdown
            }
            
        except Exception as e:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": f"Image analysis error: {str(e)}",
                "breakdown": []
            }
    
    def _extract_text_ocr(self, image: Image.Image) -> str:
        """Extract text from image using OCR."""
        try:
            # Enhance image for better OCR
            enhanced = self._enhance_image_for_ocr(image)
            
            # Perform OCR
            text = pytesseract.image_to_string(enhanced, config='--psm 6')
            
            return text.strip()
            
        except Exception as e:
            self.logger.warning(f"OCR extraction failed: {e}")
            return ""
    
    def _enhance_image_for_ocr(self, image: Image.Image) -> Image.Image:
        """Enhance image for better OCR results."""
        try:
            # Convert to grayscale
            if image.mode != 'L':
                image = image.convert('L')
            
            # Enhance contrast
            enhancer = ImageEnhance.Contrast(image)
            image = enhancer.enhance(2.0)
            
            # Enhance sharpness
            enhancer = ImageEnhance.Sharpness(image)
            image = enhancer.enhance(2.0)
            
            # Apply slight blur to reduce noise
            image = image.filter(ImageFilter.MedianFilter(size=3))
            
            return image
            
        except Exception as e:
            self.logger.warning(f"Image enhancement failed: {e}")
            return image
    
    def _analyze_text(self, text: str) -> Dict[str, Any]:
        """Analyze extracted text for malicious patterns."""
        if not text:
            return {"score": 0.0, "patterns_found": [], "reason": "No text extracted"}
        
        text_lower = text.lower()
        patterns_found = []
        max_confidence = 0.0
        
        # Check for malicious patterns
        for i, pattern in enumerate(self.compiled_patterns):
            if pattern.search(text_lower):
                confidence = 0.8 + (len(pattern.pattern) / 100)  # Longer patterns = higher confidence
                patterns_found.append({
                    "pattern": self.malicious_patterns[i],
                    "confidence": min(confidence, 1.0),
                    "match": pattern.search(text_lower).group()
                })
                max_confidence = max(max_confidence, confidence)
        
        # Check for steganography patterns
        for i, pattern in enumerate(self.stego_compiled):
            if pattern.search(text_lower):
                confidence = 0.6
                patterns_found.append({
                    "pattern": self.stego_patterns[i],
                    "confidence": confidence,
                    "match": pattern.search(text_lower).group(),
                    "type": "steganography"
                })
                max_confidence = max(max_confidence, confidence)
        
        return {
            "score": min(max_confidence, 1.0),
            "patterns_found": patterns_found,
            "reason": f"Found {len(patterns_found)} suspicious patterns" if patterns_found else "No suspicious patterns found"
        }
    
    def _detect_steganography(self, image: Image.Image) -> Dict[str, Any]:
        """Detect potential steganography in image."""
        try:
            # Convert to numpy array for analysis
            img_array = np.array(image)
            
            # Check for unusual patterns that might indicate steganography
            stego_score = 0.0
            indicators = []
            
            # Check for LSB (Least Significant Bit) patterns
            if self._check_lsb_patterns(img_array):
                stego_score += 0.3
                indicators.append("LSB pattern detected")
            
            # Check for unusual color distributions
            if self._check_color_distribution(img_array):
                stego_score += 0.2
                indicators.append("Unusual color distribution")
            
            # Check for noise patterns
            if self._check_noise_patterns(img_array):
                stego_score += 0.2
                indicators.append("Unusual noise patterns")
            
            # Check for metadata anomalies
            if self._check_metadata_anomalies(image):
                stego_score += 0.3
                indicators.append("Metadata anomalies")
            
            return {
                "score": min(stego_score, 1.0),
                "indicators": indicators,
                "reason": f"Steganography indicators: {len(indicators)}" if indicators else "No steganography detected"
            }
            
        except Exception as e:
            self.logger.warning(f"Steganography detection failed: {e}")
            return {"score": 0.0, "indicators": [], "reason": f"Detection error: {str(e)}"}
    
    def _check_lsb_patterns(self, img_array: np.ndarray) -> bool:
        """Check for LSB steganography patterns."""
        try:
            # Simple LSB analysis - check if LSBs are not random
            if len(img_array.shape) == 3:
                # Color image
                lsb = img_array[:, :, 0] & 1
            else:
                # Grayscale
                lsb = img_array & 1
            
            # Check for non-random LSB patterns
            lsb_ratio = np.sum(lsb) / lsb.size
            return not (0.4 <= lsb_ratio <= 0.6)  # Random should be around 0.5
            
        except:
            return False
    
    def _check_color_distribution(self, img_array: np.ndarray) -> bool:
        """Check for unusual color distributions."""
        try:
            if len(img_array.shape) != 3:
                return False
            
            # Check for unusual color channel correlations
            r, g, b = img_array[:, :, 0], img_array[:, :, 1], img_array[:, :, 2]
            
            # Calculate correlations
            rg_corr = np.corrcoef(r.flatten(), g.flatten())[0, 1]
            rb_corr = np.corrcoef(r.flatten(), b.flatten())[0, 1]
            gb_corr = np.corrcoef(g.flatten(), b.flatten())[0, 1]
            
            # Unusual correlations might indicate steganography
            return any(abs(corr) > 0.9 for corr in [rg_corr, rb_corr, gb_corr])
            
        except:
            return False
    
    def _check_noise_patterns(self, img_array: np.ndarray) -> bool:
        """Check for unusual noise patterns."""
        try:
            # Calculate local variance
            if len(img_array.shape) == 3:
                img_array = np.mean(img_array, axis=2)
            
            # Simple noise analysis
            variance = np.var(img_array)
            return variance > 1000  # High variance might indicate hidden data
            
        except:
            return False
    
    def _check_metadata_anomalies(self, image: Image.Image) -> bool:
        """Check for metadata anomalies."""
        try:
            # Check for unusual EXIF data
            exif = image._getexif()
            if exif:
                # Look for suspicious EXIF tags
                suspicious_tags = [271, 272, 306]  # Make, Model, DateTime
                for tag in suspicious_tags:
                    if tag in exif:
                        value = str(exif[tag]).lower()
                        if any(suspicious in value for suspicious in ['steganography', 'hidden', 'secret']):
                            return True
            
            return False
            
        except:
            return False
