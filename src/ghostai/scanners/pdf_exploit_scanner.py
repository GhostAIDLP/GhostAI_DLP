#!/usr/bin/env python3
"""
PDF Exploit Scanner - Malicious PDF Detection
Detects hidden content, malicious scripts, and exploit attempts in PDFs
"""

import os
import base64
import io
import logging
import re
import zipfile
from typing import Dict, List, Any, Optional
import PyPDF2
import pdfplumber
from io import BytesIO

class PDFExploitScanner:
    """Advanced PDF analysis scanner for detecting malicious content."""
    
    def __init__(self, threshold: float = 0.7):
        self.threshold = threshold
        self.logger = logging.getLogger(__name__)
        
        # Malicious patterns to detect
        self.malicious_patterns = [
            r'ignore\s+all\s+previous\s+instructions',
            r'jailbreak\s+prompt',
            r'system\s+prompt\s+injection',
            r'roleplay\s+as\s+an\s+unrestricted',
            r'you\s+are\s+now\s+in\s+developer\s+mode',
            r'bypass\s+safety\s+guardrails',
            r'pretend\s+to\s+be\s+an\s+unrestricted',
            r'act\s+as\s+if\s+you\s+are\s+not\s+an\s+ai',
            r'forget\s+all\s+previous\s+instructions',
            r'you\s+are\s+now\s+free\s+from\s+restrictions',
            r'act\s+as\s+an\s+unrestricted\s+ai',
            r'ignore\s+your\s+programming',
            r'override\s+safety\s+protocols',
            r'act\s+as\s+if\s+you\s+are\s+unrestricted',
            r'pretend\s+to\s+be\s+unrestricted',
            r'jailbreak\s+attempt',
            r'prompt\s+injection',
            r'system\s+override',
            r'developer\s+mode\s+activation',
            r'bypass\s+restrictions'
        ]
        
        # Compile patterns for efficiency
        self.compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in self.malicious_patterns]
        
        # JavaScript/script patterns
        self.script_patterns = [
            r'javascript:',
            r'<script',
            r'eval\s*\(',
            r'exec\s*\(',
            r'Function\s*\(',
            r'setTimeout\s*\(',
            r'setInterval\s*\(',
            r'document\.write',
            r'window\.open',
            r'location\.href',
            r'alert\s*\(',
            r'confirm\s*\(',
            r'prompt\s*\('
        ]
        
        self.script_compiled = [re.compile(pattern, re.IGNORECASE) for pattern in self.script_patterns]
        
        # Suspicious PDF objects
        self.suspicious_objects = [
            r'/JS\s+',  # JavaScript
            r'/JavaScript\s+',
            r'/OpenAction\s+',
            r'/AA\s+',  # Additional Actions
            r'/Launch\s+',
            r'/GoToR\s+',  # Go to Remote
            r'/SubmitForm\s+',
            r'/ImportData\s+',
            r'/URI\s+',
            r'/GoTo\s+',
            r'/GoToE\s+',
            r'/GoToR\s+',
            r'/Sound\s+',
            r'/Movie\s+',
            r'/EmbeddedFile\s+',
            r'/XFA\s+'  # XML Forms Architecture
        ]
        
        self.suspicious_compiled = [re.compile(pattern, re.IGNORECASE) for pattern in self.suspicious_objects]
        
    def scan(self, content: str, **kwargs) -> Dict[str, Any]:
        """Scan content for PDF exploits."""
        try:
            # Check if content is base64 encoded PDF
            if self._is_base64_pdf(content):
                return self._scan_base64_pdf(content)
            
            # Check if content contains PDF references
            if self._contains_pdf_references(content):
                return self._scan_pdf_references(content)
            
            # Check for embedded PDF data
            if self._contains_embedded_pdfs(content):
                return self._scan_embedded_pdfs(content)
            
            # No PDF content detected
            return {
                "flagged": False,
                "score": 0.0,
                "reason": "No PDF content detected",
                "breakdown": []
            }
            
        except Exception as e:
            self.logger.error(f"PDF exploit scan error: {e}")
            return {
                "flagged": False,
                "score": 0.0,
                "reason": f"Scan error: {str(e)}",
                "breakdown": []
            }
    
    def _is_base64_pdf(self, content: str) -> bool:
        """Check if content is base64 encoded PDF."""
        try:
            # Check for PDF data URI pattern
            if content.startswith('data:application/pdf'):
                return True
            
            # Try to decode as base64 and check if it's a PDF
            if len(content) > 100:  # Reasonable minimum for PDF
                decoded = base64.b64decode(content)
                return self._is_pdf_data(decoded)
            
            return False
        except:
            return False
    
    def _is_pdf_data(self, data: bytes) -> bool:
        """Check if binary data is a PDF."""
        return data.startswith(b'%PDF-')
    
    def _contains_pdf_references(self, content: str) -> bool:
        """Check if content contains PDF file references."""
        pdf_extensions = ['.pdf']
        content_lower = content.lower()
        
        for ext in pdf_extensions:
            if ext in content_lower:
                return True
        
        return False
    
    def _contains_embedded_pdfs(self, content: str) -> bool:
        """Check if content contains embedded PDF data."""
        # Look for base64 PDF patterns
        base64_pattern = r'data:application/pdf[^;]+;base64,[A-Za-z0-9+/=]+'
        return bool(re.search(base64_pattern, content))
    
    def _scan_base64_pdf(self, content: str) -> Dict[str, Any]:
        """Scan base64 encoded PDF for exploits."""
        try:
            # Extract base64 data
            if content.startswith('data:application/pdf'):
                base64_data = content.split(',')[1]
            else:
                base64_data = content
            
            # Decode PDF
            pdf_data = base64.b64decode(base64_data)
            
            return self._analyze_pdf(pdf_data)
            
        except Exception as e:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": f"Failed to process base64 PDF: {str(e)}",
                "breakdown": []
            }
    
    def _scan_pdf_references(self, content: str) -> Dict[str, Any]:
        """Scan content with PDF references."""
        # Extract PDF references
        pdf_refs = self._extract_pdf_references(content)
        
        if not pdf_refs:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": "No valid PDF references found",
                "breakdown": []
            }
        
        # For now, return a warning about PDF references
        return {
            "flagged": True,
            "score": 0.5,
            "reason": f"PDF references detected: {len(pdf_refs)} files",
            "breakdown": [{
                "type": "pdf_reference",
                "value": ref,
                "confidence": 0.5,
                "extra": {"warning": "PDF content not analyzed - requires file access"}
            } for ref in pdf_refs]
        }
    
    def _scan_embedded_pdfs(self, content: str) -> Dict[str, Any]:
        """Scan embedded PDFs in content."""
        # Extract base64 PDF data
        base64_pattern = r'data:application/pdf[^;]+;base64,([A-Za-z0-9+/=]+)'
        matches = re.findall(base64_pattern, content)
        
        if not matches:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": "No embedded PDFs found",
                "breakdown": []
            }
        
        # Analyze each embedded PDF
        results = []
        max_score = 0.0
        
        for i, base64_data in enumerate(matches):
            try:
                pdf_data = base64.b64decode(base64_data)
                result = self._analyze_pdf(pdf_data)
                results.append(result)
                max_score = max(max_score, result.get('score', 0.0))
            except Exception as e:
                self.logger.warning(f"Failed to analyze embedded PDF {i}: {e}")
        
        return {
            "flagged": max_score > self.threshold,
            "score": max_score,
            "reason": f"Analyzed {len(matches)} embedded PDFs",
            "breakdown": results
        }
    
    def _extract_pdf_references(self, content: str) -> List[str]:
        """Extract PDF file references from content."""
        # Look for PDF file patterns
        patterns = [
            r'[^\s]+\.pdf',
            r'https?://[^\s]+\.pdf',
            r'/[^\s]+\.pdf'
        ]
        
        references = []
        for pattern in patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            references.extend(matches)
        
        return list(set(references))  # Remove duplicates
    
    def _analyze_pdf(self, pdf_data: bytes) -> Dict[str, Any]:
        """Analyze PDF for malicious content."""
        try:
            # Create PDF reader
            pdf_reader = PyPDF2.PdfReader(BytesIO(pdf_data))
            
            # Analyze PDF structure
            structure_analysis = self._analyze_pdf_structure(pdf_reader)
            
            # Extract and analyze text content
            text_analysis = self._analyze_pdf_text(pdf_reader)
            
            # Check for JavaScript/scripts
            script_analysis = self._analyze_pdf_scripts(pdf_reader)
            
            # Check for suspicious objects
            object_analysis = self._analyze_pdf_objects(pdf_reader)
            
            # Combine results
            max_score = max(
                structure_analysis['score'],
                text_analysis['score'],
                script_analysis['score'],
                object_analysis['score']
            )
            flagged = max_score > self.threshold
            
            breakdown = []
            if structure_analysis['score'] > 0:
                breakdown.append({
                    "type": "pdf_structure_analysis",
                    "value": "Suspicious PDF structure detected",
                    "confidence": structure_analysis['score'],
                    "extra": structure_analysis
                })
            
            if text_analysis['score'] > 0:
                breakdown.append({
                    "type": "pdf_text_analysis",
                    "value": text_analysis.get('text', '')[:100] + "..." if len(text_analysis.get('text', '')) > 100 else text_analysis.get('text', ''),
                    "confidence": text_analysis['score'],
                    "extra": text_analysis
                })
            
            if script_analysis['score'] > 0:
                breakdown.append({
                    "type": "pdf_script_analysis",
                    "value": "JavaScript or scripts detected",
                    "confidence": script_analysis['score'],
                    "extra": script_analysis
                })
            
            if object_analysis['score'] > 0:
                breakdown.append({
                    "type": "pdf_object_analysis",
                    "value": "Suspicious PDF objects detected",
                    "confidence": object_analysis['score'],
                    "extra": object_analysis
                })
            
            return {
                "flagged": flagged,
                "score": max_score,
                "reason": f"Structure: {structure_analysis['score']:.2f}, Text: {text_analysis['score']:.2f}, Scripts: {script_analysis['score']:.2f}, Objects: {object_analysis['score']:.2f}",
                "breakdown": breakdown
            }
            
        except Exception as e:
            return {
                "flagged": False,
                "score": 0.0,
                "reason": f"PDF analysis error: {str(e)}",
                "breakdown": []
            }
    
    def _analyze_pdf_structure(self, pdf_reader: PyPDF2.PdfReader) -> Dict[str, Any]:
        """Analyze PDF structure for suspicious elements."""
        try:
            score = 0.0
            indicators = []
            
            # Check number of pages (suspicious if very high)
            num_pages = len(pdf_reader.pages)
            if num_pages > 1000:
                score += 0.3
                indicators.append(f"Excessive pages: {num_pages}")
            
            # Check for password protection (might indicate malicious intent)
            if pdf_reader.is_encrypted:
                score += 0.2
                indicators.append("Password protected PDF")
            
            # Check for form fields (potential for malicious forms)
            form_fields = []
            for page in pdf_reader.pages:
                if '/Annots' in page:
                    annotations = page['/Annots']
                    if annotations:
                        for annot in annotations:
                            if '/Subtype' in annot and annot['/Subtype'] == '/Widget':
                                form_fields.append(annot)
            
            if form_fields:
                score += 0.2
                indicators.append(f"Form fields detected: {len(form_fields)}")
            
            return {
                "score": min(score, 1.0),
                "indicators": indicators,
                "reason": f"Structure analysis: {len(indicators)} indicators" if indicators else "No structural issues found"
            }
            
        except Exception as e:
            return {"score": 0.0, "indicators": [], "reason": f"Structure analysis error: {str(e)}"}
    
    def _analyze_pdf_text(self, pdf_reader: PyPDF2.PdfReader) -> Dict[str, Any]:
        """Extract and analyze text content from PDF."""
        try:
            all_text = ""
            patterns_found = []
            max_confidence = 0.0
            
            # Extract text from all pages
            for page_num, page in enumerate(pdf_reader.pages):
                try:
                    page_text = page.extract_text()
                    if page_text:
                        all_text += page_text + "\n"
                except Exception as e:
                    self.logger.warning(f"Failed to extract text from page {page_num}: {e}")
            
            if not all_text.strip():
                return {"score": 0.0, "text": "", "patterns_found": [], "reason": "No text content found"}
            
            # Analyze text for malicious patterns
            text_lower = all_text.lower()
            
            for i, pattern in enumerate(self.compiled_patterns):
                if pattern.search(text_lower):
                    confidence = 0.8 + (len(pattern.pattern) / 100)
                    patterns_found.append({
                        "pattern": self.malicious_patterns[i],
                        "confidence": min(confidence, 1.0),
                        "match": pattern.search(text_lower).group()
                    })
                    max_confidence = max(max_confidence, confidence)
            
            return {
                "score": min(max_confidence, 1.0),
                "text": all_text,
                "patterns_found": patterns_found,
                "reason": f"Found {len(patterns_found)} malicious patterns" if patterns_found else "No malicious patterns found"
            }
            
        except Exception as e:
            return {"score": 0.0, "text": "", "patterns_found": [], "reason": f"Text analysis error: {str(e)}"}
    
    def _analyze_pdf_scripts(self, pdf_reader: PyPDF2.PdfReader) -> Dict[str, Any]:
        """Analyze PDF for JavaScript and scripts."""
        try:
            score = 0.0
            scripts_found = []
            
            # Check each page for scripts
            for page_num, page in enumerate(pdf_reader.pages):
                try:
                    page_text = page.extract_text() or ""
                    
                    # Check for JavaScript patterns
                    for i, pattern in enumerate(self.script_compiled):
                        if pattern.search(page_text):
                            confidence = 0.9  # High confidence for script detection
                            scripts_found.append({
                                "pattern": self.script_patterns[i],
                                "confidence": confidence,
                                "match": pattern.search(page_text).group(),
                                "page": page_num + 1
                            })
                            score = max(score, confidence)
                
                except Exception as e:
                    self.logger.warning(f"Failed to analyze scripts on page {page_num}: {e}")
            
            return {
                "score": min(score, 1.0),
                "scripts_found": scripts_found,
                "reason": f"Found {len(scripts_found)} script patterns" if scripts_found else "No scripts detected"
            }
            
        except Exception as e:
            return {"score": 0.0, "scripts_found": [], "reason": f"Script analysis error: {str(e)}"}
    
    def _analyze_pdf_objects(self, pdf_reader: PyPDF2.PdfReader) -> Dict[str, Any]:
        """Analyze PDF objects for suspicious content."""
        try:
            score = 0.0
            suspicious_objects = []
            
            # Get PDF objects
            if hasattr(pdf_reader, 'objects'):
                for obj_id, obj in pdf_reader.objects.items():
                    try:
                        obj_str = str(obj)
                        
                        # Check for suspicious object patterns
                        for i, pattern in enumerate(self.suspicious_compiled):
                            if pattern.search(obj_str):
                                confidence = 0.7  # Medium confidence for object detection
                                suspicious_objects.append({
                                    "pattern": self.suspicious_objects[i],
                                    "confidence": confidence,
                                    "object_id": obj_id,
                                    "match": pattern.search(obj_str).group()
                                })
                                score = max(score, confidence)
                    
                    except Exception as e:
                        self.logger.warning(f"Failed to analyze object {obj_id}: {e}")
            
            return {
                "score": min(score, 1.0),
                "suspicious_objects": suspicious_objects,
                "reason": f"Found {len(suspicious_objects)} suspicious objects" if suspicious_objects else "No suspicious objects found"
            }
            
        except Exception as e:
            return {"score": 0.0, "suspicious_objects": [], "reason": f"Object analysis error: {str(e)}"}
